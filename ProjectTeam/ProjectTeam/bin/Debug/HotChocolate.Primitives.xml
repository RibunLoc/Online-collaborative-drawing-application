<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HotChocolate.Primitives</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            /// <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:HotChocolate.Types.DirectiveLocation">
            <summary>
            A Directive can be adjacent to many parts of the GraphQL language,
            a DirectiveLocation describes one such possible adamancies.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Query">
            <summary>
            Location adjacent to a query operation.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Mutation">
            <summary>
            Location adjacent to a mutation operation.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Subscription">
            <summary>
            Location adjacent to a subscription operation.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Field">
            <summary>
            Location adjacent to a field.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.FragmentDefinition">
            <summary>
            Location adjacent to a fragment definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.FragmentSpread">
            <summary>
            Location adjacent to a fragment spread.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.InlineFragment">
            <summary>
            Location adjacent to an inline fragment.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.VariableDefinition">
            <summary>
            Location adjacent to a field.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Schema">
            <summary>
            Location adjacent to a schema definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Scalar">
            <summary>
            Location adjacent to a scalar definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Object">
            <summary>
            Location adjacent to an object type definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.FieldDefinition">
            <summary>
            Location adjacent to a field definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.ArgumentDefinition">
            <summary>
            Location adjacent to an argument definition
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Interface">
            <summary>
            Location adjacent to an interface definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Union">
            <summary>
            Location adjacent to a union definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.Enum">
            <summary>
            Location adjacent to an enum definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.EnumValue">
            <summary>
            Location adjacent to an enum value definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.InputObject">
            <summary>
            Location adjacent to an input object type definition.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.DirectiveLocation.InputFieldDefinition">
            <summary>
            Location adjacent to an input object field definition.
            </summary>
        </member>
        <member name="T:HotChocolate.Types.TypeKind">
            <summary>
            Specifies the GraphQL type kind.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Interface">
             <summary>
             <para>
             GraphQL interfaces represent a list of named fields and their arguments.
             GraphQL objects and interfaces can then implement these interfaces
             which requires that the implementing type will define all fields defined by those
             interfaces.
             </para>
             <para>
             Fields on a GraphQL interface have the same rules as fields on a GraphQL object;
             their type can be Scalar, Object, Enum, Interface, or Union, or any wrapping type
             whose base type is one of those five.
             </para>
             <para>
             For example, an interface NamedEntity may describe a required field and types such
             as Person or Business may then implement this interface to guarantee this field will
             always exist.
             </para>
             <para>
             Types may also implement multiple interfaces. For example, Business implements both
             the NamedEntity and ValuedEntity interfaces in the example below.
             </para>
            
             <code>
             interface NamedEntity {
               name: String
             }
            
             interface ValuedEntity {
               value: Int
             }
            
             type Person implements NamedEntity {
               name: String
               age: Int
             }
            
             type Business implements NamedEntity &amp; ValuedEntity {
               name: String
               value: Int
               employeeCount: Int
             }
             </code>
             </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Object">
            <summary>
            <para>
            GraphQL operations are hierarchical and composed, describing a tree of information.
            While Scalar types describe the leaf values of these hierarchical operations,
            Objects describe the intermediate levels.
            </para>
            <para>
            GraphQL Objects represent a list of named fields, each of which yield a value of a
            specific type. Object values should be serialized as ordered maps, where the selected
            field names (or aliases) are the keys and the result of evaluating the field is the value,
            ordered by the order in which they appear in the selection set.
            </para>
            <para>
            All fields defined within an Object type must not have a name which begins
            with "__" (two underscores), as this is used exclusively by
            GraphQLâ€™s introspection system.
            </para>
            </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Union">
             <summary>
             <para>
             GraphQL Unions represent an object that could be one of a list of GraphQL Object types,
             but provides for no guaranteed fields between those types.
             They also differ from interfaces in that Object types declare what interfaces
             they implement, but are not aware of what unions contain them.
             </para>
             <para>
             With interfaces and objects, only those fields defined on the type can be queried directly;
             to query other fields on an interface, typed fragments must be used.
             This is the same as for unions, but unions do not define any fields,
             so no fields may be queried on this type without the use of type refining
             fragments or inline fragments (with the exception of the meta-field __typename).
             </para>
             <para>For example, we might define the following types:</para>
            
             <code>
             union SearchResult = Photo | Person
            
             type Person {
               name: String
               age: Int
             }
            
             type Photo {
               height: Int
               width: Int
             }
            
             type SearchQuery {
               firstSearchResult: SearchResult
             }
             </code>
             </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.InputObject">
             <summary>
             <para>
             A GraphQL Input Object defines a set of input fields; the input fields are either scalars,
             enums, or other input objects. This allows arguments to accept arbitrarily complex structs.
             </para>
             <para>In this example, an Input Object called Point2D describes x and y inputs:</para>
            
             <code>
             input Point2D {
               x: Float
               y: Float
             }
             </code>
             </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Enum">
             <summary>
             <para>
             GraphQL Enum types, like Scalar types, also represent leaf values in a GraphQL type system.
             However Enum types describe the set of possible values.
             </para>
             <para>
             Enums are not references for a numeric value, but are unique values in their own right.
             They may serialize as a string: the name of the represented value.
             </para>
             <para>In this example, an Enum type called Direction is defined:</para>
            
             <code>
             enum Direction {
               NORTH
               EAST
               SOUTH
               WEST
             }
             </code>
             </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Scalar">
            <summary>
            Scalar types represent primitive leaf values in a GraphQL type system.
            GraphQL responses take the form of a hierarchical tree;
            the leaves on these trees are GraphQL scalars.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.List">
            <summary>
            Indicates this type is a list. `ofType` is a valid field.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.NonNull">
            <summary>
            Indicates this type is a non-null. `ofType` is a valid field.
            </summary>
        </member>
        <member name="F:HotChocolate.Types.TypeKind.Directive">
            <summary>
            <para>
            A GraphQL schema describes directives which are used to annotate various parts of a
            GraphQL document as an indicator that they should be evaluated differently by a
            validator, executor, or client tool such as a code generator.
            </para>
            <para>https://spec.graphql.org/draft/#sec-Type-System.Directives</para>
            </summary>
        </member>
        <member name="T:HotChocolate.Utilities.NameUtils">
            <summary>
            Helper methods to handle GraphQL names.
            </summary>
        </member>
        <member name="M:HotChocolate.Utilities.NameUtils.EnsureGraphQLName(System.String,System.String)">
            <summary>
            Ensures that the name is a valid GraphQL type- or field-name.
            </summary>
            <param name="name">
            The name.
            </param>
            <param name="argumentName">
            The argument name.
            </param>
            <returns>
            Returns a string that represents a valid GraphQL type- or field-name.
            </returns>
        </member>
        <member name="M:HotChocolate.Utilities.NameUtils.IsValidGraphQLName(System.String)">
            <summary>
            Checks if the provided name is a valid GraphQL type or field name.
            </summary>
            <param name="name">
            The name that shall be checked.
            </param>
            <returns>
            <c>true</c>, if the name is a valid GraphQL name;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:HotChocolate.Utilities.NameUtils.IsValidGraphQLName(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Checks if the provided name is a valid GraphQL type or field name.
            </summary>
            <param name="name">
            The name that shall be checked.
            </param>
            <returns>
            <c>true</c>, if the name is a valid GraphQL name;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:HotChocolate.Utilities.NameUtils.MakeValidGraphQLName(System.String)">
            <summary>
            Takes the provided name and replaces invalid
            characters with an underscore.
            </summary>
            <param name="name">
            A name that shall be made a value GraphQL name.
            </param>
            <returns>Returns a valid GraphQL name.</returns>
        </member>
        <member name="T:HotChocolate.SchemaCoordinate">
            <summary>
            <para>
            A <see cref="T:HotChocolate.SchemaCoordinate"/> is a human-readable string that uniquely identifies a
            schema element within a GraphQL Schema.
            A schema element is a specific instance of a named type, field, input field, enum value,
            field argument, directive, or directive argument.
            A <see cref="T:HotChocolate.SchemaCoordinate"/> is always unique. Each schema element may be referenced
            by exactly one possible schema coordinate.
            </para>
            <para>
            A <see cref="T:HotChocolate.SchemaCoordinate"/> may refer to either a defined or built-in schema element.
            For example, `String` and `@deprecated(reason:)` are both valid schema coordinates which refer
            to built-in schema elements. However it must not refer to a meta-field.
            For example, `Business.__typename` is <b>not</b> a valid schema coordinate.
            </para>
            <para>
            SchemaCoordinate:
             - Name
             - Name.Name
             - Name.Name(Name:)
             - @Name
             - @Name (Name:)
            </para>
            </summary>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.#ctor(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new instance of <see cref="T:HotChocolate.SchemaCoordinate"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="name"/> is <c>null</c> or <see cref="F:System.String.Empty" />.
            </exception>
            <exception cref="T:System.ArgumentException">
            - A directive cannot contain a <paramref name="memberName"/>.
            - A <paramref name="argumentName"/>. without a <paramref name="memberName"/> is only allowed
            on directive coordinates.
            </exception>
        </member>
        <member name="P:HotChocolate.SchemaCoordinate.OfDirective">
            <summary>
            Specifies if this <see cref="T:HotChocolate.Language.SchemaCoordinateNode"/> is a coordinate of a directive.
            </summary>
        </member>
        <member name="P:HotChocolate.SchemaCoordinate.Name">
            <summary>
            The name of the referenced <see cref="T:HotChocolate.Language.INamedSyntaxNode"/>
            </summary>
        </member>
        <member name="P:HotChocolate.SchemaCoordinate.MemberName">
            <summary>
            The optional name of the referenced field or enum value
            </summary>
        </member>
        <member name="P:HotChocolate.SchemaCoordinate.ArgumentName">
            <summary>
            The optional name of the referenced argument
            </summary>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.ToSyntax">
            <summary>
            Gets the syntax representation of this <see cref="T:HotChocolate.SchemaCoordinate"/>.
            </summary>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.ToString">
            <summary>
            Gets the string representation of this <see cref="T:HotChocolate.SchemaCoordinate"/>.
            </summary>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.TryParse(System.String,System.Nullable{HotChocolate.SchemaCoordinate}@)">
            <summary>
            Tries to parse a <see cref="T:HotChocolate.SchemaCoordinate"/> from a <see cref="T:System.String"/>.
            </summary>
            <param name="s">The string that may represent a <see cref="T:HotChocolate.SchemaCoordinate"/>.</param>
            <param name="coordinate">
            If the string <paramref name="s"/> represented a valid schema coordinate string this
            will be the parsed schema coordinate.
            </param>
            <returns>
            <c>true</c> if the string was a valid representation of a schema coordinate.
            </returns>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.Parse(System.String)">
            <summary>
            Parses a schema coordinate string representation.
            </summary>
            <param name="s">The schema coordinate string representation.</param>
            <returns>
            Returns the parses schema coordinate.
            </returns>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.FromSyntax(HotChocolate.Language.SchemaCoordinateNode)">
            <summary>
            Creates a <see cref="T:HotChocolate.SchemaCoordinate"/> from a <see cref="T:HotChocolate.Language.SchemaCoordinateNode"/>.
            </summary>
            <param name="node">
            The syntax node.
            </param>
            <returns>
            Returns the <see cref="T:HotChocolate.SchemaCoordinate"/> instance.
            </returns>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.Equals(HotChocolate.SchemaCoordinate)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">
            An object to compare with this object.
            </param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.Equals(System.Object)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="obj">
            An object to compare with this object.
            </param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="obj" /> parameter;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:HotChocolate.SchemaCoordinate.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
    </members>
</doc>
